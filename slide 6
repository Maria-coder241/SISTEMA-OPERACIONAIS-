ğŸ”¹ Deadlocks
DefiniÃ§Ã£o: SituaÃ§Ã£o em que um conjunto de processos fica permanentemente bloqueado, esperando por recursos que nunca serÃ£o liberados.


Exemplos: Impressora e gravador disputados por processos diferentes, banco de dados bloqueado por mÃºltiplos acessos.



ğŸ”¹ Recursos
SequÃªncia de uso: requisitar â†’ usar â†’ liberar.


Tipos:


PreemptÃ­veis: podem ser retirados sem prejuÃ­zo (ex.: memÃ³ria).


NÃ£o-preemptÃ­veis: nÃ£o podem ser tomados sem causar falha (ex.: impressora).


Deadlocks geralmente ocorrem em recursos nÃ£o-preemptÃ­veis.



ğŸ”¹ CondiÃ§Ãµes necessÃ¡rias para deadlock (as 4 condiÃ§Ãµes):
ExclusÃ£o mÃºtua â†’ um recurso sÃ³ pode ser usado por um processo por vez.


Posse e espera â†’ processo mantÃ©m recursos enquanto pede outros.


NÃ£o-preempÃ§Ã£o â†’ recurso nÃ£o pode ser retirado Ã  forÃ§a.


Espera circular â†’ cadeia de processos esperando recursos uns dos outros.



ğŸ”¹ Modelagem
Grafos de alocaÃ§Ã£o:


Processos = cÃ­rculos, Recursos = quadrados.


Setas mostram recursos possuÃ­dos ou requisitados.


Ciclos no grafo indicam possÃ­vel deadlock.



ğŸ”¹ EstratÃ©gias contra Deadlock
Ignorar o problema (â€œalgoritmo do avestruzâ€).


DetecÃ§Ã£o e recuperaÃ§Ã£o: deixa ocorrer, detecta e resolve.


RecuperaÃ§Ã£o: preempÃ§Ã£o, retrocesso (checkpoints), eliminaÃ§Ã£o de processos.


Evitar: usar algoritmos para manter o sistema em estado seguro (ex.: Banco do banqueiro).


PrevenÃ§Ã£o: eliminar uma das 4 condiÃ§Ãµes (ex.: ordem global de requisiÃ§Ãµes, pedir todos os recursos de uma vez).



ğŸ”¹ Outras questÃµes
InaniÃ§Ã£o (starvation): processo pode nunca conseguir recurso (ex.: sempre chegam tarefas menores antes).


SoluÃ§Ã£o: polÃ­ticas justas, como FIFO.
 Deadlocks â€“ Complemento

ğŸ”¹ Exemplo de Deadlock
Dois processos e dois recursos:
Processo P1 segura Impressora e quer Disco.
Processo P2 segura Disco e quer Impressora.

RepresentaÃ§Ã£o em grafo:
P1 â†’ Disco
Disco â†’ P2
P2 â†’ Impressora
Impressora â†’ P1

 Temos um ciclo fechado â†’ isso Ã© deadlock.

ğŸ”¹ Exemplo sem Deadlock
P1 usa Impressora e depois libera.
P2 sÃ³ requisita Impressora apÃ³s P1 liberar.

Grafo:
P1 â†’ Impressora (usa e libera)
P2 â†’ Impressora (recebe depois)

 NÃ£o hÃ¡ ciclo â†’ logo nÃ£o hÃ¡ deadlock.

ğŸ”¹ Como Descobrir se Existe Deadlock
Modelo de Grafo de AlocaÃ§Ã£o:


Processos = cÃ­rculos, Recursos = quadrados.


Se houver um ciclo no grafo â†’ deadlock.


Se nÃ£o houver ciclo â†’ sem deadlock.


Algoritmo do Banqueiro (estado seguro):


Simula alocaÃ§Ã£o de recursos.


Verifica se todos os processos conseguem terminar em alguma ordem.


Se nÃ£o conseguem â†’ sistema em estado inseguro â†’ pode ocorrer deadlock.



ğŸ”¹ EstratÃ©gias para Evitar Deadlock
PrevenÃ§Ã£o (elimina uma das 4 condiÃ§Ãµes):


ExclusÃ£o mÃºtua â†’ impossÃ­vel de eliminar.


Posse e espera â†’ processos devem requisitar todos os recursos de uma vez.


NÃ£o-preempÃ§Ã£o â†’ permitir preempÃ§Ã£o (retirar recurso Ã  forÃ§a).


Espera circular â†’ impor ordem global de requisiÃ§Ãµes.


Evitar (mantÃ©m sistema em estado seguro):


Ex.: Algoritmo do Banqueiro â†’ concede recursos apenas se nÃ£o levar a estado inseguro.


DetecÃ§Ã£o e RecuperaÃ§Ã£o:


Deixa o deadlock ocorrer, depois detecta (analisando ciclos no grafo).


Recupera liberando recursos por:


PreempÃ§Ã£o (tirar recurso de processo).


Rollback (voltar a um checkpoint).


Matar processos (liberar recursos Ã  forÃ§a).


Ignorar (Ostrich Algorithm):


Simplesmente nÃ£o trata â†’ usado em sistemas onde deadlocks sÃ£o raros.



ğŸ”¹ ResumÃ£o das SoluÃ§Ãµes
Prevenir â†’ mudar como os recursos sÃ£o requisitados.


Evitar â†’ sÃ³ concede recursos se for seguro (banqueiro).


Detectar e Recuperar â†’ deixa acontecer e resolve depois.


Ignorar â†’ nÃ£o faz nada.


 Exemplo Resolvido â€“ Algoritmo do Banqueiro
CenÃ¡rio
Recursos disponÃ­veis (total):


A = 10, B = 5, C = 7


Matriz de AlocaÃ§Ã£o (Allocation) â†’ quanto cada processo jÃ¡ tem:


    A  B  C
P0   0  1  0
P1   2  0  0
P2   3  0  2
P3   2  1  1
P4   0  0  2

Matriz de MÃ¡xima Necessidade (Max) â†’ quanto cada processo pode precisar no mÃ¡ximo:


    A  B  C
P0   7  5  3
P1   3  2  2
P2   9  0  2
P3   2  2  2
P4   4  3  3


Passo 1: Calcular "Need" (Max - Allocation)
    A  B  C
P0   7  4  3
P1   1  2  2
P2   6  0  0
P3   0  1  1
P4   4  3  1


Passo 2: Recursos DisponÃ­veis
Total â€“ soma da AlocaÃ§Ã£o atual:
Total = (10, 5, 7)
Î£ Allocation = (7, 2, 5)
Available = (3, 3, 2)


Passo 3: Verificar se existe uma sequÃªncia segura
Work = (3,3,2)


P1 precisa (1,2,2) â†’ pode ser atendido 


ApÃ³s terminar, libera recursos de P1: Work = (3+2, 3+0, 2+0) = (5,3,2)


Work = (5,3,2)


P3 precisa (0,1,1) â†’ pode ser atendido 


Libera recursos de P3: Work = (5+2, 3+1, 2+1) = (7,4,3)


Work = (7,4,3)


P0 precisa (7,4,3) â†’ pode ser atendido 


Libera recursos de P0: Work = (7+0, 4+1, 3+0) = (7,5,3)


Work = (7,5,3)


P2 precisa (6,0,0) â†’ pode ser atendido 


Libera recursos de P2: Work = (7+3, 5+0, 3+2) = (10,5,5)


Work = (10,5,5)


P4 precisa (4,3,1) â†’ pode ser atendido 


Libera recursos de P4: Work = (10,5,5) + (0,0,2) = (10,5,7)



Passo 4: SequÃªncia Segura
Ordem encontrada:
P1 â†’ P3 â†’ P0 â†’ P2 â†’ P4

Como existe uma sequÃªncia segura, o sistema NÃƒO estÃ¡ em deadlock.

Resumindo o raciocÃ­nio de prova:
Calcular Need = Max â€“ Allocation.


Calcular Available = Total â€“ Î£Allocation.


Verificar, com Available, se hÃ¡ processos que podem terminar e liberar recursos.


Se todos os processos conseguirem terminar â†’ estado seguro.


Se algum ficar preso sem recursos â†’ estado inseguro (possÃ­vel deadlock).

Exemplo 1 â€“ Sem Deadlock (Estado Seguro)
Recursos totais
A = 10, B = 5

AlocaÃ§Ã£o (Allocation)
    A  B
P0   5  1
P1   2  1

MÃ¡ximo (Max)
    A  B
P0   7  3
P1   4  2

CÃ¡lculo
Need = Max â€“ Allocation


    A  B
P0   2  2
P1   2  1

Available = Total â€“ Î£Allocation = (10,5) â€“ (7,2) = (3,3)


Teste
Work = (3,3).


P0 precisa (2,2) â†’ pode ser atendido  â†’ libera (5,1) â†’ Work = (8,4).


P1 precisa (2,1) â†’ pode ser atendido  â†’ libera (2,1) â†’ Work = (10,5).


Todos os processos terminam â†’ estado seguro, sem deadlock.

 Exemplo 2 â€“ Com Deadlock (Estado Inseguro)
Recursos totais
A = 6, B = 3

AlocaÃ§Ã£o (Allocation)
    A  B
P0   3  1
P1   2  1

MÃ¡ximo (Max)
    A  B
P0   5  2
P1   3  2

CÃ¡lculo
Need = Max â€“ Allocation


    A  B
P0   2  1
P1   1  1

Available = Total â€“ Î£Allocation = (6,3) â€“ (5,2) = (1,1)


Teste
Work = (1,1).


P0 precisa (2,1) â†’ nÃ£o pode ser atendido .


P1 precisa (1,1) â†’ pode ser atendido  â†’ libera (2,1) â†’ Work = (3,2).


Agora Work = (3,2).


P0 precisa (2,1) â†’ pode ser atendido  â†’ libera (3,1) â†’ Work = (6,3).


Fim â†’ todos terminaram.


âš  Opa! Parece seguro. Vamos ajustar o exemplo para realmente dar deadlock:

 Exemplo 2 Ajustado â€“ Deadlock Real
Recursos totais
A = 4, B = 2

AlocaÃ§Ã£o (Allocation)
    A  B
P0   2  1
P1   2  1

MÃ¡ximo (Max)
    A  B
P0   3  2
P1   3  2

CÃ¡lculo
Need = Max â€“ Allocation


    A  B
P0   1  1
P1   1  1

Available = Total â€“ Î£Allocation = (4,2) â€“ (4,2) = (0,0)


Teste
Work = (0,0).


P0 precisa (1,1) â†’ nÃ£o pode ser atendido .


P1 precisa (1,1) â†’ nÃ£o pode ser atendido .


Nenhum processo pode prosseguir.


 Nenhuma sequÃªncia segura â†’ deadlock.

Como Identificar Deadlock
Calcular Need e Available.


Tentar achar uma ordem em que processos terminem.


Se em algum ponto nenhum processo puder ser atendido, e ainda restarem processos â†’ deadlock.



 Como Resolver
PrevenÃ§Ã£o â†’ eliminar uma das 4 condiÃ§Ãµes (ex.: ordem global, pedir todos os recursos de uma vez).


Evitar â†’ usar o Algoritmo do Banqueiro sempre.


DetecÃ§Ã£o e RecuperaÃ§Ã£o:


Identificar ciclos no grafo.


PreempÃ§Ã£o (forÃ§ar liberaÃ§Ã£o).


Rollback (voltar checkpoint).


Matar processos.
